#coding=utf-8
"""
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解
"""

"""
题目是说，给你一串数，有正有负 要求出最大的连续子串。

其实就是标准的动态规划问题： 
随着遍历这个数组，在到每一个位置的时候，弄一个局部最大L值，代表以当前位置为结尾的最大子串，比如说我遍历到第i个，那么以第i个为结尾的最大子串就是我们要求的L。

比如这个题目： 
-2 , 1, −3,4,−1,2,1,−5,4 
位置0，L=x=-2，没得选 
位置1，要以x=1为结尾的最大的，那肯定不要带上之前的-2,只要1就好L=x=1 
位置2，因为本身x=-3，加上上一个位置L 是正数1，所以L=L+x=-3+1=-2。 
下面以此类推得到：

对应的L应该是： 
-2, 1, -2,4,3,5,6,-1,3

而全局最大值G就是我们最终想要的结果， 
肯定这个全局最大值出自局部最大值。 
（因为全局最大的那个子串的结尾肯定在数组里，言外之意就是不管怎么样这个G都肯定出自L） 
最后找到最大的那个L就是我们想要的G了。

"""
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        l=g=-10000000#可能有负数，所以一开始不能初始化为0
        for i in nums:
            l=max(i,i+l)
            g=max(l,g)
        return g

if __name__ == "__main__":
    print Solution().maxSubArray([-2,1,-3,4,-1,2,1,-5,4])